Alright, deep breath. Let‚Äôs re-explain **only the /classroom part** and its **utils** like you‚Äôve never seen databases before. I‚Äôll use super simple mental models, tiny snippets, and repeat the key ideas so they stick. ü§ù

# Big mental model (zero DB knowledge)

Think of **DynamoDB** as a giant set of **folders**.
Each **folder** has a name called **PK** (Partition Key).
Inside a folder are **files** sorted by a name called **SK** (Sort Key).

* To **get** something fast, you need to know *which folder (PK)* and *which file (SK)*.
* To **list** a bunch of related things, you open the folder (PK) and look at all files inside.
* A **GSI** is just a **second set of folders** sorted by a different label, so you can find stuff another way.

For **classrooms**, you actually have **two folders systems (two tables)**:

* Table **`classrooms`** ‚Äî one item per classroom
* Table **`memberships`** ‚Äî relationship links between **users** and **classrooms** (this is your ‚Äúwho‚Äôs in what‚Äù list)

---

# What each table stores (with concrete examples)

## 1) Table: `classrooms`

* **Primary key:** `classroomID` (think: the unique ID of the class)
* **Also stored:** `classroomName`, `school`, `createdAt`, `teacherId`, `teacherName`, **`joinCode`**
* **Extra index (GSI):** `joinCode-index` so you can look up a class by its join code

### Example item in `classrooms`

```json
{
  "classroomID": "c-12345",
  "classroomName": "Chemistry 101",
  "school": "IC Beirut",
  "createdAt": "2025-08-01T09:15:30.150Z",
  "teacherId": "user-sub-aaa",
  "teacherName": "Mona Ahmad",
  "joinCode": "AB1724520412731"
}
```

* If you **know** the classroomID ‚Üí you can **Get** it directly.
* If you **only** know the joinCode ‚Üí you **Query** the **`joinCode-index`** to find it.

## 2) Table: `memberships`

This is the trickiest part, but it‚Äôs simple if you see it as **two folders per relationship**.

We store **two items** for each ‚Äúuser is in classroom‚Äù relationship:

* Put one file inside the **`USER#<userId>` folder** that points to the class
* Put another file inside the **`CLASSROOM#<classId>` folder** that points to the user

Why? So we can **list both ways** very fast:

* ‚ÄúWhat classes is this user in?‚Äù ‚Üí open `PK=USER#<userId>`
* ‚ÄúWho‚Äôs in this class?‚Äù ‚Üí open `PK=CLASSROOM#<classId>`

### Example items in `memberships` when a student joins class `c-12345`

```json
{
  "PK": "USER#user-sub-bbb",
  "SK": "CLASSROOM#c-12345",
  "role": "student",
  "joinedAt": "2025-08-01T10:00:00Z"
}
```

```json
{
  "PK": "CLASSROOM#c-12345",
  "SK": "USER#user-sub-bbb",
  "role": "student",
  "joinedAt": "2025-08-01T10:00:00Z"
}
```

When the **teacher creates** a classroom, you also write two **membership** items with role `instructor` for the teacher.

---

# The four classroom endpoints (what they do with the tables)

## 1) `POST /classroom/create` (instructor only)

**Goal:** Make a new classroom and link the teacher to it.

**Steps your code does:**

1. **Auth check**: must be an instructor (`claims['custom:role'] === 'instructor'`)
2. **Build** a classroom object:

   ```ts
   {
     classroomID: uuidv4(),
     classroomName: body.classroomName,
     school: body.school,
     createdAt: new Date().toISOString(),
     teacherId: claims.sub,
     teacherName: claims['given_name'] + ' ' + claims['family_name'],
     joinCode: generateJoinCode()
   }
   ```
3. **Validate** with `ClassroomSchema` (Zod).
4. **Write** to `classrooms` with a guard: `attribute_not_exists(classroomID)` (prevents accidental overwrite).
5. **Create 2 memberships** with role `instructor`:

   * `PK=USER#<teacherId>`,    `SK=CLASSROOM#<classroomID>`
   * `PK=CLASSROOM#<classID>`, `SK=USER#<teacherId>`

**Why two membership rows?**
So later you can quickly answer both ‚Äúmy classes‚Äù and ‚Äúwho‚Äôs in this class‚Äù.

---

## 2) `POST /classroom/join` (student)

**Goal:** Join a class by **joinCode** (because students don‚Äôt know classroomID).

**Steps your code does:**

1. **Auth check**.
2. **Validate** body has `joinCode`.
3. **Find the classroom** by `joinCode` using the **GSI**:

   ```ts
   query Table 'classrooms' on Index 'joinCode-index'
   where joinCode = :jc
   ```

   Get back the classroom item ‚Üí read its `classroomID`.
4. **Check** if the membership already exists:

   * `get` from `memberships` with `PK=USER#<userId>`, `SK=CLASSROOM#<classroomID>`
5. If not‚Ä¶ **create 2 membership rows** (role `student`), same pattern as above.

**Why the GSI again?**
Because the main key of the `classrooms` table is `classroomID`.
Join codes are a different lookup path ‚Üí that‚Äôs what GSIs are for.

---

## 3) `GET /classroom/list` (any user)

**Goal:** Show **my classrooms**.

**Steps your code does:**

1. **Auth check** ‚Üí get `userId = claims.sub`.
2. **Query `memberships` by user**:

   ```ts
   query Table 'memberships'
   where PK = USER#<userId>
   ```

   You‚Äôll get items like `SK=CLASSROOM#c-12345`, `SK=CLASSROOM#c-77777`, ‚Ä¶
3. Extract the **classroom IDs** from those SKs.
4. For each classroom ID, **Get** the classroom item from `classrooms`.
5. Return the list (you omit `teacherId` in the response ‚Äî your choice).

---

## 4) `POST /classroom/members` (any member; you might restrict later)

**Goal:** List members of a classroom (human-friendly info).

**Steps your code does:**

1. **Auth check**.
2. **Validate** body has `classroomID`.
3. **Query `memberships` by classroom**:

   ```ts
   query Table 'memberships'
   where PK = CLASSROOM#<classroomID>
   ```

   You‚Äôll get items like `SK=USER#user-sub-...` for all members.
4. (With the ‚Äústudents only‚Äù filter) keep only those rows with `role === 'student'`.
5. For each student id, call **Cognito** to get nice fields (name, email).
6. Return `{ members: [...] }`.

**Why do we call Cognito here?**
The membership rows store IDs + role + joinedAt (minimal).
Cognito is the source of truth for user profile (names, email, custom attrs).

---

# The utils, in plain language

## Dynamo client

```ts
export const dobClient = new AWS.DynamoDB.DocumentClient();
```

Think: a helper we use to **talk** to Dynamo using normal JS objects.

## Writing a classroom

```ts
await dobClient.put({
  TableName: 'classrooms',
  Item: classroom,
  ConditionExpression: 'attribute_not_exists(classroomID)'
}).promise();
```

* **put** = ‚Äúsave this object by its key‚Äù
* **ConditionExpression** = ‚Äúonly if a row with this key doesn‚Äôt already exist‚Äù (safety guard)

## Getting a classroom by ID

```ts
await dobClient.get({
  TableName: 'classrooms',
  Key: { classroomID }
}).promise();
```

* **get** = ‚Äúfetch exactly this one item by primary key‚Äù

## Getting a classroom by joinCode (GSI)

```ts
await dobClient.query({
  TableName: 'classrooms',
  IndexName: 'joinCode-index',
  KeyConditionExpression: 'joinCode = :jc',
  ExpressionAttributeValues: { ':jc': joinCode }
}).promise();
```

* **query** = ‚Äúopen the folder (partition key) on an index and list matching files‚Äù
* Here the ‚Äúfolder label‚Äù is `joinCode` (because on the GSI, **joinCode is the partition key**)

## Writing a membership

```ts
await dobClient.put({
  TableName: 'memberships',
  Item: membership,
  ConditionExpression: 'attribute_not_exists(PK) AND attribute_not_exists(SK)'
}).promise();
```

* Saves one of the two relationship rows
* The **condition** prevents duplicate writes of the same `(PK, SK)` pair

## List my classroom IDs

```ts
await dobClient.query({
  TableName: 'memberships',
  KeyConditionExpression: 'PK = :pk',
  ExpressionAttributeValues: { ':pk': `USER#${userId}` }
}).promise();
```

* Open the folder `USER#<id>` and read all files (their SKs give classroom IDs)

## List student IDs in a classroom

```ts
await dobClient.query({
  TableName: 'memberships',
  KeyConditionExpression: 'PK = :pk',
  ExpressionAttributeValues: { ':pk': `CLASSROOM#${classroomId}` }
}).promise();
```

* Open the folder `CLASSROOM#<id>` and read all files (their SKs give user IDs)
* Then filter for `role === 'student'` if you only want students

---

# Why two membership rows again? (this is the core Dynamo idea)

**Relational DBs (like MySQL)** would join a **Users** table with a **Enrollments** table with a **Classrooms** table to answer your queries.

**DynamoDB (NoSQL)** doesn‚Äôt do joins.
So you **pre-compute** the two main query paths you need:

* By **user** ‚Üí what classes?
  Put an item under `PK = USER#<userId>` for each class.

* By **class** ‚Üí which users?
  Put an item under `PK = CLASSROOM#<classId>` for each user.

It‚Äôs **data duplication on purpose** for speed and simplicity of reads.
This pattern is called the **adjacency list / bidirectional index** in single-table designs.

---

# Tiny cheat sheet (what to use when)

* **Create class**
  `put(classrooms)` + 2 √ó `put(memberships)`
* **Join by code**
  `query(classrooms on joinCode-index)` ‚Üí `classroomID` ‚Üí 2 √ó `put(memberships)`
* **List my classes**
  `query(memberships PK=USER#me)` ‚Üí for each, `get(classrooms)`
* **List members**
  `query(memberships PK=CLASSROOM#id)` ‚Üí (filter students) ‚Üí for each, Cognito profile

---

# Common gotchas (you‚Äôre already avoiding most)

* **Know your keys.**
  `get` only works with the table‚Äôs primary key.
  Anything else ‚Üí you need a **query** on an **index** (like the joinCode GSI).

* **Condition expressions matter.**
  A misspelled attribute name means your safety check does nothing.
  (You fixed `classroomId` ‚Üí `classroomID`.)

* **User identifiers.**
  Your membership uses `claims.sub` as the user id.
  Cognito‚Äôs `adminGetUser` often needs the **Username**, which can differ.
  (Your `fetchStudentInfo` includes a fallback to resolve `sub ‚Üí Username`.)

* **Two writes = two chances to fail.**
  Doing both membership writes in one **transaction** is ideal, but since you‚Äôre in ‚Äúfix only‚Äù mode, you can keep current behavior and just watch logs.

---

If this finally clicks, great. If one piece still feels fuzzy (PK/SK, GSI, or why two rows), tell me exactly where it‚Äôs blurry and I‚Äôll zoom in with a tiny drawing or a 30-second example.
